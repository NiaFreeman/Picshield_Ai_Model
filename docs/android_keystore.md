Android Keystore & Hidden Folder — PicShield implementation guide
===============================================================

This document explains how to securely implement the Hidden folder on Android using the Android Keystore (recommended). It includes a Kotlin example that:

- Generates a hardware-backed AES key (or wraps an AES key with an RSA key) stored in the Android Keystore.
- Uses AES-GCM for file encryption (no insecure modes like ECB).
- Shows a pattern for biometric gating using AndroidX Biometric.

Security goals
--------------

- Keys protecting the Hidden folder must not be exportable in plaintext.
- Use hardware-backed keystores (StrongBox) where available.
- Decrypt only after a biometric/authentication check (BiometricPrompt or device credential) when showing an image.
- Keep thumbnails blurred and store clear thumbnails only inside encrypted storage.

High-level options
------------------

1) Preferred (Android 9+): Generate a symmetric AES key in Keystore (KeyGenerator) with setIsStrongBoxBacked(true) when available.
   - Use AES/GCM/NoPadding for encryption.
   - Key is non-exportable — encryption/decryption occurs via Android Keystore's Cipher.

2) Alternative (compat): Generate an RSA wrapping key in Keystore and store a generated AES key wrapped with RSA.
   - Useful for older devices that don't support hardware AES keys in Keystore.

Biometric gating
----------------

- Use AndroidX Biometric (BiometricPrompt) to require a biometric prior to creating a Cipher that can perform decryption. The Keystore supports requiring user authentication for using the key (setUserAuthenticationRequired(true)).
- Consider setUserAuthenticationValidityDurationSeconds: 0 to require biometric for each use (most secure) or a short window (a usability tradeoff).

Sample Kotlin: generate AES key in Android Keystore
--------------------------------------------------

```kotlin
// Call this once during setup or when creating the Hidden folder key
fun generateSymmetricKey(alias: String) {
    val keyGenerator = KeyGenerator.getInstance(
        KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore")

    val builder = KeyGenParameterSpec.Builder(
        alias,
        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
    )
        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
        .setKeySize(256)
        .setUserAuthenticationRequired(true) // require biometric/credential
        //.setUserAuthenticationValidityDurationSeconds(5*60) // optional window

    // try StrongBox where possible
    try {
        builder.setIsStrongBoxBacked(true)
    } catch (e: Exception) {
        // StrongBox not available; continue without it
    }

    keyGenerator.init(builder.build())
    keyGenerator.generateKey()
}
```

Encrypting a file (Kotlin)
--------------------------

Use the generated key from Keystore to create a Cipher for encryption. Store the IV with the ciphertext (IV is not secret). For AES-GCM we recommend 12-byte IVs.

```kotlin
fun encryptFile(alias: String, plaintext: ByteArray): Pair<ByteArray, ByteArray> {
    val keyStore = KeyStore.getInstance("AndroidKeyStore").apply { load(null) }
    val secretKey = keyStore.getKey(alias, null) as SecretKey

    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    cipher.init(Cipher.ENCRYPT_MODE, secretKey)
    val iv = cipher.iv // 12 bytes generated by system
    val ciphertext = cipher.doFinal(plaintext)
    return Pair(iv, ciphertext)
}
```

Decrypting with biometric prompt
--------------------------------

To decrypt, create a BiometricPrompt that authenticates the user and then obtain a CryptoObject (Cipher) to use with the keystore key. Use `setUserAuthenticationRequired(true)` when generating the key so that the keystore enforces user auth.

```kotlin
// prepare Cipher for decryption
fun getDecryptCipher(alias: String, iv: ByteArray): Cipher {
    val keyStore = KeyStore.getInstance("AndroidKeyStore").apply { load(null) }
    val secretKey = keyStore.getKey(alias, null) as SecretKey
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    val spec = GCMParameterSpec(128, iv)
    cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)
    return cipher
}

// In Activity/Fragment: show BiometricPrompt with CryptoObject
val cipher = getDecryptCipher(alias, iv)
val cryptoObject = BiometricPrompt.CryptoObject(cipher)
val prompt = BiometricPrompt(this, executor, object : BiometricPrompt.AuthenticationCallback() {
    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
        val c = result.cryptoObject?.cipher
        val plaintext = c?.doFinal(ciphertext)
        // use plaintext (e.g., render image in memory)
    }
})

prompt.authenticate(promptInfo, cryptoObject)
```

File storage recommendations
----------------------------

- Store encrypted file bytes in app-private storage (Context.getFilesDir() or getNoBackupFilesDir()).
- Do not create clear-text files in external storage or public DCIM directories.
- For thumbnails, store blurred thumbnails outside the clear folder, and store clear thumbnails only inside encrypted storage.

Migration from browser demo
---------------------------

- The web demo stores an AES key in IndexedDB for simplicity. For Android native, replace IndexedDB storage with Keystore-managed keys.
- Use the same detection JSON format; only the storage layer changes.

Notes & pitfalls
---------------

- Never store raw unencrypted image bytes or raw keys in SharedPreferences or log them.
- AES-GCM requires correct handling of IVs and associated data (AAD) when used. You can include metadata as AAD to bind it to ciphertext.
- If you need cloud backup, encrypt with a separate key wrapped by a user-provided passphrase or use secure backup with user consent and clear UI.

References
----------

- Android Keystore documentation: https://developer.android.com/training/articles/keystore
- BiometricPrompt: https://developer.android.com/training/sign-in/biometric-auth
- Best practices on encryption: OWASP Mobile Top 10
